GIL锁
===
## 引题
经常有人拿python执行效率说事。
写一个死循环
```python
i = 0
while True:
    i += 0
```
上述死循环代码的C、Java实现会让CPU100%，但python实现CPU占用率只有30%-50%。说明python代码无法完全发挥CPU的性能，原因是GIL锁的存在。

## GIL锁产生历史
GIL(global interpreter lock) 全局解释器锁，python设计之初，家用电脑还都是单核CPU。另一方面为了解释器设计简单（内存回收）和数据安全。
python中某个线程想要执行，先要拿到GIL锁（好像程序运行的通行证），才会被允许进入CPU执行指令，当这个线程一段指令执行完毕后，被CPU挂起，释放解释器GIL锁，然后其它线程再争夺GIL锁，取得锁后进入CPU调度。
python解释器默认cpython，c线程不能直接操作CPU，只能被GIL锁控制，同一时间只能一个线程，所以说python程序只能让CPU的一个核心满载。
（课外）pypyjpython没有GIL锁，运行效率较高。

## 建议和场景
1. 避免CPU密集型程序。例如水利、航天轨道、圆周率、找素数等。
2. 适合IO密集型，例如下载图片、写数据等。
目前网站需求主要是IO密集型，平时任务CPU性能过剩、主要缺硬盘性能，固态硬盘出现大大提升体验。平时爬虫、网站、轻度计算，python完全可以胜任。

建议：使用多进程提高CPU利用率。好像影分身。

GIL锁在python3中有所改进：
在python2中只有一个gill锁，要么获取要么释放，没有锁的线程要等待。
在python3中ticks计数GIL锁，达到一定时间后再释放，对CPU密集型程序更加友好。但仍没有解决同一时间只能执行一个线程。
由于生态已经建立，所以解释器底层不敢有大改动。